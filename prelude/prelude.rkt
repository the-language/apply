#lang racket
(require "vrectord.rkt")
(require "racket.rkt")
(require "num.rkt")
(require "hash.rkt")
(require "macros.rkt")

(require "../conf.rkt")
(prelude
 get
 '((define null? __null?)
   (define raise __raise)
   (define (with-exception-handler handler thunk)
     (if (procedure? handler)
         (if (procedure? thunk)
             (__with-exception-handler handler thunk)
             (error "with-exception-handler: isn't procedure" thunk))
         (error "with-exception-handler: isn't procedure" handler)))
   (define cons __cons)
   (define procedure? __procedure?)
   (define number? __number?)
   (define (number->string x)
     (if (number? x)
         (__number->string x)
         (error "number->string: isn't number" x)))
   (define (string->number x)
     (if (string? x)
         (__string->number x)
         (error "string->number: isn't string" x)))
   (define (string-append x y)
     (if (string? x)
         (if (string? y)
             (__string-append x y)
             (error "string-append: isn't string" y))
         (error "string-append: isn't string" x)))
   (define string? __string?)
   (define symbol? __symbol?)
   (define boolean? __boolean?)
   (define (symbol->string x)
     (if (symbol? x)
         (__symbol->string x)
         (error "symbol->string: isn't symbol" x)))
   (define (string->symbol x)
     (if (string? x)
         (__string->symbol x)
         (error "string->symbol: isn't string" x)))
   (define (apply f xs)
     (if (procedure? f)
         (if (list? xs)
             (__apply f xs)
             (error "apply: isn't list" xs))
         (error "apply: isn't procedure" f)))
   (define (car p)
     (if (pair? p)
         (__car p)
         (error "car: isn't pair" p)))
   (define (cdr p)
     (if (pair? p)
         (__cdr p)
         (error "cdr: isn't pair" p)))

   (define (error . xs) (raise (cons 'error xs)))
   (define (not x) (if x #f #t))
   (define (string . xs) (list->string xs))
   (define (displayln x) (display x) (newline))
   (define eqv? equal?)

   (defmacro delay-force
     (λ (x)
       `(delay (force ,x))))
   (define (make-promise x) (if (promise? x) x (delay x)))
   (define (memroizeeq f) f) ; zaoqil-core
   (define (memorize1eq f) f) ; zaoqil-core

   (define (list . xs) xs)
   (define (list? xs) (or (null? xs) (and (pair? xs) (list? (cdr xs)))))
   (define (map f xs)
     (if (null? xs)
         '()
         (cons (f (car xs)) (map f (cdr xs)))))
   (define (append xs ys)
     (if (null? xs)
         ys
         (cons (car xs) (append (cdr xs) ys))))
   (define (filter f xs)
     (if (null? xs)
         '()
         (if (f (car xs))
             (cons (car xs) (filter f (cdr xs)))
             (filter f (cdr xs)))))
   (define (foldl f x xs)
     (if (null? xs)
         x
         (foldl f (f (car xs) x) (cdr xs))))
   (define (length xs)
     (if (null? xs)
         0
         (+ 1 (length (cdr xs)))))
   (define (list-ref xs i)
     (if (zero? i)
         (car xs)
         (list-ref (cdr xs) (- i 1))))
   (define (%reverse xs rs)
     (if (null? xs)
         rs
         (%reverse (cdr xs) (cons (car xs) rs))))
   (define (reverse xs)
     (%reverse xs '()))
   (define (member x xs)
     (if (null? xs)
         #f
         (or (equal? (car xs) x) (member x (cdr xs)))))
   (define (ormap f xs)
     (if (null? xs)
         (or)
         (or (f (car xs)) (ormap f (cdr xs)))))
   (define (andmap f xs)
     (cond
       [(null? xs) (and)]
       [(null? (cdr xs)) (and (f (car xs)))]
       [else (and (f (car xs)) (andmap f (cdr xs)))]))
   (define (caar x) (car (car x)))
   (define (cadr x) (car (cdr x)))
   (define (cdar x) (cdr (car x)))
   (define (cddr x) (cdr (cdr x)))
   (define (caaar x) (car (car (car x))))
   (define (caadr x) (car (car (cdr x))))
   (define (cadar x) (car (cdr (car x))))
   (define (caddr x) (car (cdr (cdr x))))
   (define (cdaar x) (cdr (car (car x))))
   (define (cdadr x) (cdr (car (cdr x))))
   (define (cddar x) (cdr (cdr (car x))))
   (define (cdddr x) (cdr (cdr (cdr x))))
   (define first car)
   (define second cadr)
   (define third caddr)
   (define (assf f xs)
     (if (null? xs)
         #f
         (if (f (caar xs))
             (car xs)
             (assf f (cdr xs)))))
   (define (assoc x xs) (assf (λ (y) (equal? x y)) xs))

   (define gensym% (atom! 0))
   (define (gensym) (atom-map! (λ (x) (+ x 1)) gensym%))
   ))
